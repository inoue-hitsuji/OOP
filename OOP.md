## **クラス**とは、その内部にメソッド（手続きや関数）を定義できるユーザ定義型である。

クラスを使うことで、データとそのデータを操作するメソッドを一つの単位としてまとめることができる。これにより、関連する機能を論理的にグループ化し、コードの再利用性と保守性を向上させることができる。

例：
```java
class Rectangle {
    private double width;
    private double height;
    
    public Rectangle(double w, double h) {
        width = w;
        height = h;
    }
    
    public double area() {
        return width * height;
    }
}
```

## **オブジェクト指向プログラミング**とは、クラス階層に焦点を当てるプログラミングである。
クラス階層は、**実行時多相性**と**カプセル化**を提供する。

- **実行時多相性**（polymorphism）：スーパークラスやインターフェースの参照を通じて、サブクラスのオブジェクトに対して適切なメソッドを実行時に選択できる機能。これにより、同じインターフェースで異なる実装を扱える。
- **カプセル化**：データとその操作を一つの単位にまとめ、外部からの直接アクセスを制限することで、データの整合性を保つ仕組み。

クラス階層を活用することで、コードの拡張性が高まり、新しい機能を追加する際に既存のコードを変更せずに済む。例えば、新しい図形（`Triangle`など）を追加する場合、`Shape`を**継承**するだけで既存のコード（`Shape`型の変数やメソッド）をそのまま利用できる。

例：
```java
abstract class Shape {
    public abstract double area();  // 実行時多相性
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double r) {
        radius = r;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}
```

## **オブジェクト**は、実行時にメモリ上に存在する、クラスによって定義されたデータ構造の実体である。

ストラウストラップの定義によれば、オブジェクトは「メモリ上で連続している一つの領域」である。これはC++の値型オブジェクトを前提とした定義であり、オブジェクトのインスタンスデータが連続したメモリ領域に配置されることを意味する。ただし、言語実装によっては、オブジェクトのメモリ配置は異なる場合がある。例えば、Javaではオブジェクトはヒープ領域に確保され、参照を通じてアクセスされる。オブジェクトのインスタンスデータ（プリミティブ型フィールドや参照値）は一つのメモリ領域にまとまって配置されるが、参照型フィールドが指す先のオブジェクトは別の領域に存在する。

例：
```java
Rectangle rect = new Rectangle(10.0, 5.0);  // rectがオブジェクト
double a = rect.area();                     // オブジェクトのメソッドを呼び出し
```

## オブジェクトの生存期間

オブジェクトの生存期間は、そのコンストラクタが実行を完了した時点から、ガベージコレクタによって回収される時点までである。

- **コンストラクタ**：オブジェクトの生成時に自動的に呼び出される特殊なメソッド。オブジェクトの初期化を行う。
- **ガベージコレクション**：Javaでは、使用されなくなったオブジェクトは自動的にガベージコレクタによって回収される。ただし、ファイルやネットワーク接続などのリソースは、明示的にクローズする必要がある。

この生存期間の管理により、リソースの適切な取得と解放が保証され、メモリリークやリソースリークを防ぐことができる。Javaでは、try-with-resources文を使用することで、リソースの自動解放が可能になる。

例：
```java
class Resource implements AutoCloseable {
    private int[] data;
    
    public Resource() {
        data = new int[100];  // コンストラクタ：リソース取得
    }
    
    @Override
    public void close() {
        // リソース解放（実際のリソース管理が必要な場合はここで処理）
        // ガベージコレクタが自動的にメモリを回収する
    }
}

// 使用例
try (Resource res = new Resource()) {
    // リソースを使用
}  // 自動的にclose()が呼ばれる
```

（参考文献）
ビャーネ・ストラウストラップ. プログラミング言語C++ 第4版. SBクリエイティブ株式会社. Kindle 版. 
なお、具体例は Java のコードとした。